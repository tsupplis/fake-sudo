#!/bin/sh
# License summary (BSD 2-Clause):
# Copyright (c) 2025, tsupplis
# Redistribution and use in source/binary forms, with or without modification,
# are permitted if the copyright notice, conditions, and disclaimer are kept.
# Provided "AS IS" without warranties; no liability for damages.
# sudo - A compatibility wrapper that maps sudo commands to doas or provides
#        equivalent behavior using sh when doas is not available
#
# This script attempts to translate common sudo options to doas equivalents
# or simulate the behavior when doas is not installed.

set -e

# Error helpers
die() {
    echo "$1" >&2
    exit "${2:-1}"
}

die_with_help() {
    echo "$1" >&2
    echo "Try 'sudo --help' for more information." >&2
    exit "${2:-1}"
}

warn() {
    echo "sudo: warning: $1" >&2
}

get_doas_safe_path() {
    os_name="$(uname -s 2>/dev/null || echo unknown)"
    case "$os_name" in
        OpenBSD)
            echo "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"
            ;;
        FreeBSD|DragonFly)
            echo "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"
            ;;
        NetBSD)
            echo "/usr/bin:/bin:/usr/sbin:/sbin:/usr/pkg/bin:/usr/local/bin"
            ;;
        Darwin)
            echo "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/local/bin"
            ;;
        Linux)
            echo "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/local/bin"
            ;;
        SunOS)
            echo "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/local/bin"
            ;;
        Haiku)
            echo "/boot/system/bin:/boot/home/config/bin"
            ;;
        *)
            echo "/usr/bin:/bin:/usr/sbin:/sbin"
            ;;
    esac
}

validate_opt_value() {
    opt_label="$1"
    opt_value="$2"
    case "$opt_value" in
        ""|*[!A-Za-z0-9._-]*)
            die "sudo: invalid $opt_label value: $opt_value" 1
            ;;
    esac
}

run_doas() {
    if [ -n "$opt_target_group" ]; then
        warn "-g option not supported by doas, ignoring"
    fi

    if [ "$opt_preserve_env" -eq 1 ]; then
        warn "-E option requested: preserving a minimal safe environment"
        for var in LANG LC_ALL LC_CTYPE LC_MESSAGES LC_COLLATE LC_TIME LC_NUMERIC LC_MONETARY TERM COLORTERM; do
            val=$(printenv "$var")
            if [ -n "$val" ]; then
                set -- "$var=$val" "$@"
            fi
        done
        set -- "PATH=$DOAS_SAFE_PATH" "$@"
        set -- env -i "$@"
    fi

    # Insert end-of-options marker before command, then prepend doas options
    set -- -- "$@"

    # Prepend doas options in reverse order to preserve argument integrity
    if [ -n "$opt_auth_style" ]; then
        set -- -a "$opt_auth_style" "$@"
    fi
    if [ "$opt_non_interactive" -eq 1 ]; then
        set -- -n "$@"
    fi
    set -- -u "$opt_target_user" "$@"

    if [ "$opt_background" -eq 1 ]; then
        PATH="$DOAS_SAFE_PATH" doas "$@" &
    else
        exec env PATH="$DOAS_SAFE_PATH" doas "$@"
    fi
}

run_shell() {
    if [ "$opt_background" -eq 1 ]; then
        # shellcheck disable=SC2086
        if [ "$opt_preserve_env" -eq 1 ]; then
            warn "-E option requested: preserving a minimal safe environment"
            for var in LANG LC_ALL LC_CTYPE LC_MESSAGES LC_COLLATE LC_TIME LC_NUMERIC LC_MONETARY TERM COLORTERM; do
                val=$(printenv "$var")
                if [ -n "$val" ]; then
                    set -- "$var=$val" "$@"
                fi
            done
            set -- "PATH=$DOAS_SAFE_PATH" "$@"
            set -- env -i "$@"
        fi
        case "$1" in
            -*) sh -c 'exec "$@"' sh -- "$@" & ;;
            *) "$@" & ;;
        esac
    else
        # shellcheck disable=SC2086
        if [ "$opt_preserve_env" -eq 1 ]; then
            warn "-E option requested: preserving a minimal safe environment"
            for var in LANG LC_ALL LC_CTYPE LC_MESSAGES LC_COLLATE LC_TIME LC_NUMERIC LC_MONETARY TERM COLORTERM; do
                val=$(printenv "$var")
                if [ -n "$val" ]; then
                    set -- "$var=$val" "$@"
                fi
            done
            set -- "PATH=$DOAS_SAFE_PATH" "$@"
            set -- env -i "$@"
        fi
        case "$1" in
            -*) exec sh -c 'exec "$@"' sh -- "$@" ;;
            *) exec "$@" ;;
        esac
    fi
}

# Check if doas is available
DOAS_SAFE_PATH="$(get_doas_safe_path)"
have_doas=0
if PATH="$DOAS_SAFE_PATH" command -v doas >/dev/null 2>&1; then
    have_doas=1
fi

# Function to show usage/help
show_help() {
    if [ "$have_doas" -eq 1 ]; then
        cat <<'EOF'
sudo - execute a command as another user (compatibility wrapper)

Usage: sudo [options] [command [arg ...]]

Mode: Using doas backend (privilege escalation enabled)

Common options:
  -h, --help              Display this help message
  -V, --version           Display version information
  -u user, --user=user    Run command as specified user (default: root)
  -s, --shell             Run shell as target user
  -i, --login             Run login shell as target user
  -n, --non-interactive   Non-interactive mode, fail if password required
  -b, --background        Run command in background
  -a style                Use specified authentication style
  -C config               Check doas configuration file
  -L, --clear-persist     Clear persisted authentication

Limited support options:
  -v, --validate          Update cached credentials (limited support)
  -k, --reset-timestamp   Invalidate cached credentials (limited support)
  -K, --remove-timestamp  Remove all cached credentials (limited support)
  -E, --preserve-env      Preserve user environment (warning: limited support)
  -g group, --group=group Run with specified group (warning: not supported by doas)
  -H, --set-home          Set HOME to target user's home (not implemented)
  -l, --list              List privileges (not implemented)

Note: This wrapper translates sudo options to doas equivalents.
EOF
    else
        cat <<'EOF'
sudo - execute a command as another user (compatibility wrapper)

Usage: sudo [options] [command [arg ...]]

Mode: Using shell backend (NO privilege escalation - development/testing mode)

Common options:
  -h, --help              Display this help message
  -V, --version           Display version information
  -s, --shell             Run shell (as current user)
  -i, --login             Run login shell (as current user)
  -b, --background        Run command in background

Ignored options (warnings will be shown):
  -u user, --user=user    Run as specified user (ignored: requires doas)
  -n, --non-interactive   Non-interactive mode (ignored: requires doas)
  -g group, --group=group Run with specified group (ignored: requires doas)
  -a style                Authentication style (ignored: requires doas)
  -C config               Check configuration (ignored: requires doas)
  -L, --clear-persist     Clear persisted auth (ignored: requires doas)
  -l, --list              List privileges (not implemented)
  -v, --validate          Validate credentials (ignored: requires doas)
  -k, --reset-timestamp   Reset timestamp (ignored: requires doas)
  -K, --remove-timestamp  Remove timestamp (ignored: requires doas)
  -E, --preserve-env      Preserve environment (ignored: requires doas)
  -H, --set-home          Set HOME (ignored: requires doas)
EOF
    fi
}

# Function to show version
show_version() {
    if [ "$have_doas" -eq 1 ]; then
        echo "sudo compatibility wrapper (using doas backend)"
        PATH="$DOAS_SAFE_PATH" doas -V 2>/dev/null || echo "doas version: unknown"
    else
        echo "sudo compatibility wrapper (using sh backend)"
        echo "Version: 1.0.0"
    fi
}

# Initialize variables
opt_target_user="root"
opt_run_shell=0
opt_login_shell=0
opt_preserve_env=0
opt_set_home=0
opt_background=0
opt_non_interactive=0
opt_list_privileges=0
opt_validate=0
opt_reset_timestamp=0
opt_remove_timestamp=0
opt_target_group=""
opt_auth_style=""
opt_check_config=""
opt_clear_persist=0
command=""
end_of_options_only=0
arg_sep="$(printf '\037')"
command_args_buf=""
: "$opt_set_home"

parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -V|--version)
                show_version
                exit 0
                ;;
            -u|--user)
                shift
                if [ $# -eq 0 ]; then
                    die "sudo: option requires an argument -- u" 1
                fi
                opt_target_user="$1"
                validate_opt_value "user" "$opt_target_user"
                shift
                ;;
            --user=*)
                opt_target_user="${1#--user=}"
                validate_opt_value "user" "$opt_target_user"
                shift
                ;;
            -g|--group)
                shift
                if [ $# -eq 0 ]; then
                    die "sudo: option requires an argument -- g" 1
                fi
                opt_target_group="$1"
                validate_opt_value "group" "$opt_target_group"
                shift
                ;;
            --group=*)
                opt_target_group="${1#--group=}"
                validate_opt_value "group" "$opt_target_group"
                shift
                ;;
            -s|--shell)
                opt_run_shell=1
                shift
                ;;
            -i|--login)
                opt_login_shell=1
                shift
                ;;
            -E|--preserve-env)
                opt_preserve_env=1
                shift
                ;;
            -H|--set-home)
                opt_set_home=1
                shift
                ;;
            -b|--background)
                opt_background=1
                shift
                ;;
            -n|--non-interactive)
                opt_non_interactive=1
                shift
                ;;
            -l|--list)
                opt_list_privileges=1
                shift
                ;;
            -v|--validate)
                opt_validate=1
                shift
                ;;
            -k|--reset-timestamp)
                opt_reset_timestamp=1
                shift
                ;;
            -K|--remove-timestamp)
                opt_remove_timestamp=1
                shift
                ;;
            -a)
                shift
                if [ $# -eq 0 ]; then
                    die "sudo: option requires an argument -- a" 1
                fi
                opt_auth_style="$1"
                validate_opt_value "auth style" "$opt_auth_style"
                shift
                ;;
            -C)
                shift
                if [ $# -eq 0 ]; then
                    die "sudo: option requires an argument -- C" 1
                fi
                opt_check_config="$1"
                shift
                ;;
            -L|--clear-persist)
                opt_clear_persist=1
                shift
                ;;
            --)
                shift
                if [ $# -eq 0 ]; then
                    command=""
                    end_of_options_only=1
                    return 0
                fi
                command="$1"
                shift
                command_args_buf="$(printf '%s\037' "$@")"
                command_args_buf="${command_args_buf%"$arg_sep"}"
                break
                ;;
            -* )
                die_with_help "sudo: unknown option: $1" 1
                ;;
            *)
                command="$1"
                shift
                command_args_buf="$(printf '%s\037' "$@")"
                command_args_buf="${command_args_buf%"$arg_sep"}"
                break
                ;;
        esac
    done
}

# Parse arguments
parse_args "$@"

# Handle special operations that don't execute commands
if [ "$opt_clear_persist" -eq 1 ]; then
    if [ "$have_doas" -eq 1 ]; then
        exec env PATH="$DOAS_SAFE_PATH" doas -L
    else
        die "sudo: -L option requires doas (not available)" 1
    fi
fi

if [ "$opt_validate" -eq 1 ] || [ "$opt_reset_timestamp" -eq 1 ] || [ "$opt_remove_timestamp" -eq 1 ]; then
    if [ "$have_doas" -eq 1 ]; then
        # doas doesn't have exact equivalents, but we can try a no-op command
        if [ "$opt_remove_timestamp" -eq 1 ]; then
            PATH="$DOAS_SAFE_PATH" doas -L 2>/dev/null || true
        fi
        echo "sudo: credential caching operations have limited support" >&2
    else
        echo "sudo: credential caching not supported without doas" >&2
    fi
    exit 0
fi

if [ "$opt_list_privileges" -eq 1 ]; then
    die "sudo: -l option not implemented" 1
fi

# Handle shell invocation
if [ "$opt_run_shell" -eq 1 ] || [ "$opt_login_shell" -eq 1 ]; then
    user_shell="${SHELL:-/bin/sh}"
    
    if [ "$have_doas" -eq 1 ]; then
        if [ "$opt_login_shell" -eq 1 ]; then
            run_doas -s
        else
            run_doas "$user_shell"
        fi
    else
        # Fallback: just run the shell (ignoring user switching)
        if [ "$opt_target_user" != "root" ] && [ "$opt_target_user" != "$(id -un)" ]; then
            warn "cannot switch to user '$opt_target_user' without doas, running as current user"
        fi
        exec "$user_shell"
    fi
fi

# No command specified
if [ "$end_of_options_only" -eq 1 ]; then
    die_with_help "sudo: no command specified after --" 1
elif [ -z "$command" ]; then
    die_with_help "sudo: no command specified" 1
fi

# Normalize command and arguments into positional parameters
if [ -n "$command_args_buf" ]; then
    old_ifs="$IFS"
    IFS="$arg_sep"
    set -f
    # shellcheck disable=SC2086
    set -- "$command" $command_args_buf
    set +f
    IFS="$old_ifs"
else
    set -- "$command"
fi
# Check config mode
if [ -n "$opt_check_config" ]; then
    if [ "$have_doas" -eq 1 ]; then
        exec env PATH="$DOAS_SAFE_PATH" doas -C "$opt_check_config" "$@"
    else
        die "sudo: -C option requires doas (not available)" 1
    fi
fi

# Execute command with doas
if [ "$have_doas" -eq 1 ]; then
    run_doas "$@"
else
    # Fallback implementation using plain sh (no user switching)
    if [ "$opt_target_user" != "root" ] && [ "$opt_target_user" != "$(id -un)" ]; then
        warn "cannot switch to user '$opt_target_user' without doas, running as current user"
    fi
    
    if [ -n "$opt_target_group" ]; then
        warn "-g option not supported without doas"
    fi
    
    # Execute the command directly
    run_shell "$@"
fi
